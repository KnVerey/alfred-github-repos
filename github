#!/opt/rubies/2.3.3/bin/ruby

require './xml_builder'

require 'json'
require 'net/http'
require 'cgi'
require 'open3'

class AuthenticationError < StandardError; end
class APIError < StandardError; end

class Github
  KEYCHAIN_ENTRY = "alfred-github-workflow".freeze
  BASE_URI = "https://api.github.com"
  USER_CACHE_FILE = ".user-cache"

  def store_token(token)
    _, err, st = Open3.capture3("security add-generic-password -a $USER -s #{KEYCHAIN_ENTRY} -w #{token} -U")
    File.delete(USER_CACHE_FILE) if File.exist?(USER_CACHE_FILE)
    st.success?
  end

  def search_repo(query)
    load_token!
    search_user_repos(query)
  end

  def refresh_users
    File.delete(USER_CACHE_FILE) if File.exist?(USER_CACHE_FILE)
    load_token!
    user_and_orgs
  rescue AuthenticationError, APIError => e
    puts e.message
    false
  end

  private

  def load_token!
    @token, err, st = Open3.capture3("security find-generic-password -a $USER -s #{KEYCHAIN_ENTRY} -w")
    if !st.success?
      raise AuthenticationError.new("Unable to retrieve access token from keychain / #{err}")
    elsif !@token || @token.empty?
      raise AuthenticationError.new("Invalid token retrieved from keychain / Please re-run gh-auth with valid token")
    end
  end

  def search_user_repos(keyword)
    return [] if !keyword || keyword.empty?
    user_params = user_and_orgs.each_with_object("") { |u, params| params << " user:#{u}" }
    results = get "/search/repositories", { "q" => "#{keyword}#{user_params} in:name sort:updated" }
    results['items'].map do |repo|
      { 'name' => repo['full_name'], 'url' => repo['html_url'] }
    end
  end

  def user_and_orgs
    @user_and_orgs ||= []
    return @user_and_orgs unless @user_and_orgs.empty?

    if File.exist?(USER_CACHE_FILE)
      @user_and_orgs = File.read(USER_CACHE_FILE).split("\n")
    end
    return @user_and_orgs unless @user_and_orgs.empty?

    results = get "/user/orgs"
    results.each_with_object([]) do |org, orgs|
      @user_and_orgs << org["login"]
    end
    user_result = get "/user"
    @user_and_orgs << user_result["login"]
    File.write(USER_CACHE_FILE, @user_and_orgs.join("\n"))
    @user_and_orgs
  end

  def get(path, params = {})
    params['per_page'] = 10 # number visible in Alfred
    qs = params.map {|k, v| "#{CGI.escape k.to_s}=#{CGI.escape v.to_s}"}.join("&")
    uri = URI("#{BASE_URI}#{path}?#{qs}")

    response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) do |http|
      req = Net::HTTP::Get.new(uri)
      req['Accept'] = "application/vnd.github.v3+json"
      req['Authorization'] = "token #{@token}"
      http.request(req)
    end
    if response.code.to_i > 399
      raise APIError.new("Error communicating with Github / GET #{path} #{response.code}")
    end
    JSON.parse(response.body)
  end
end

case ARGV[0]
when '--auth'
  success = Github.new.store_token(ARGV[1])
  exit success
when '--refresh'
  success = Github.new.refresh_users
  exit success
when '--search'
  begin
    results = Github.new.search_repo(ARGV[1] || '')

    output = XmlBuilder.build do |xml|
      xml.items do
        results.each do |repo|
          xml.item Item.new(repo['url'], repo['url'], repo['name'], repo['url'], 'yes')
        end
      end
    end
    puts output
  rescue AuthenticationError => e
    main_message, secondary_message = e.message.split("/", 2)
    output = XmlBuilder.build do |xml|
      xml.items do
        xml.item Item.new('gh-error', 'gh-auth', main_message, secondary_message, 'yes')
      end
    end
    puts output
  rescue APIError => e
    main_message, secondary_message = e.message.split("/", 2)
    output = XmlBuilder.build do |xml|
      xml.items do
        xml.item Item.new('gh-error', 'api-fail', main_message, secondary_message, 'yes')
      end
    end
    puts output
  end
end
