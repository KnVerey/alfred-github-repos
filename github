#!/opt/rubies/2.3.3/bin/ruby

require './xml_builder'

require 'json'
require 'net/http'
require 'cgi'
require 'open3'

class AuthenticationError < StandardError; end

class Github
  KEYCHAIN_ENTRY = "alfred-github-workflow".freeze
  BASE_URI = "https://api.github.com"
  CACHE_FILE_NAME = ".repositoriescache"

  def store_token(token)
    _, err, st = Open3.capture3("security add-generic-password -D 'secure note' -a $USER -s #{KEYCHAIN_ENTRY} -w #{token} -U")
    st.success?
  end

  def search_repo(query)
    repos = load_and_cache_user_repos
    results = repos.select do |repo|
      repo['name'] =~ Regexp.new(query, 'i')
    end
    results += search_all_repos(query) if query =~ /\//
    results.uniq
  end

  def rebuild_user_repos_cache
    File.delete(CACHE_FILE_NAME) if File.exists?(CACHE_FILE_NAME)
    cache_all_repos_for_user
  end

  def ensure_authenticated!
    load_token!
    res = get "/"
    if res.has_key?('error')
      raise AuthenticationError.new("Github authentication failed / Please re-run gh-auth with valid token")
    end
  end

  private

  def load_token!
    @token, err, st = Open3.capture3("security find-generic-password -a $USER -s #{KEYCHAIN_ENTRY} -w")
    if !st.success?
      raise AuthenticationError.new("Unable to retrieve access token from keychain / #{err}")
    elsif !@token || @token.empty?
      raise AuthenticationError.new("Invalid token retrieved from keychain / Please re-run gh-auth with valid token")
    end
  end

  def load_and_cache_user_repos
    if File.exists?(CACHE_FILE_NAME)
      JSON.parse(File.read(CACHE_FILE_NAME))
    else
      cache_all_repos_for_user
    end
  end

  # TODO: probably will do a search request instead of fetching all at once
  def cache_all_repos_for_user
    ensure_authenticated!
    repos = []
    repos += get_user_repos
    get_user_orgs.each do |org|
      repos += get_org_repos( org['login'] )
    end
    File.open(CACHE_FILE_NAME, 'w') do |f|
      f.write repos.to_json
    end
    repos
  end

  def get_user_repos
    res = get "/user/repos"
    if res.is_a?(Array)
      res.map do |repo|
        { 'name' => repo['full_name'], 'url' => repo['html_url'] }
      end
    else # TODO: handle error
      []
    end
  end

  def get_user_orgs
    res = get "/user/orgs"
    if res.is_a?(Array)
      res.map do |org|
        { 'login' => org['login'] }
      end
    else # TODO: handle error
      []
    end
  end

  def get_org_repos(org)
    res = get "/orgs/#{org}/repos"
    if res.is_a?(Array)
      res.map do |repo|
        { 'name' => repo['full_name'], 'url' => repo['html_url'] }
      end
    else # TODO: handle error
      []
    end
  end

  def search_all_repos(query)
    return [] if !query || query.length == 0
    ensure_authenticated!

    parts = query.split('/', 2)

    if parts.length == 1 and parts[0].length > 0
      res = get "/search/repositories", { "q" => query }
      if res.is_a?(Hash) and res.has_key?('items')
        res['items'].map do |repo|
          { 'name' => repo['full_name'], 'url' => repo['html_url'] }
        end
      else # TODO: handle error
        []
      end
    elsif parts.length == 2 and parts[0].length > 0
      user = parts[0]
      userQuery = parts[1]
      res = get "/users/#{user}/repos"
      if res.is_a?(Array)
        repos = res.select do |repo|
          repo['name'] =~ Regexp.new(userQuery, 'i')
        end
        repos.map do |repo|
          { 'name' => repo['full_name'], 'url' => repo['html_url'] }
        end
      else # TODO: handle error
        []
      end
    else
      []
    end
  end

  def get(path, params = {})
    params['per_page'] = 100  # Note: 100 is the max. - see https://developer.github.com/v3/#pagination
    qs = params.map {|k, v| "#{CGI.escape k.to_s}=#{CGI.escape v.to_s}"}.join("&")
    uri = URI("#{BASE_URI}#{path}?#{qs}")

    json_all = []

    begin

      res = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) do |http|
        req = Net::HTTP::Get.new(uri)
        req['Accept'] = "application/vnd.github.v3+json"
        req['Authorization'] = "token #{@token}"
        http.request(req)
      end

      json = JSON.parse(res.body)

      if not res.kind_of? Net::HTTPSuccess
        return { 'error' => json['message'] }
      end

      if json.is_a?(Array) # result is paged
        json_all.concat json
        # See if more pages must be retrieved by testing for and extracting the link header's "next" URL.
        # See https://developer.github.com/guides/traversing-with-pagination/
        uri = URI((res['link'].match /<([^>]+)>;\s*rel="next"/)[1]) rescue nil
        break if uri.nil?
      else  # result is not an array and therefore not paged
        json_all = json
        break
      end

    end while true

    json_all
  end
end

github = Github.new
begin
  case ARGV[0]
  when '--update'
    github.rebuild_user_repos_cache
  when '--auth'
    success = github.store_token(ARGV[1])
    exit (success ? 0 : 1)
  when '--search'
    results = github.search_repo(ARGV[1] || '')

    output = XmlBuilder.build do |xml|
      xml.items do
        if results.length > 0
          results.each do |repo|
            xml.item Item.new(repo['url'], repo['url'], repo['name'], repo['url'], 'yes')
          end
        else
          xml.item Item.new(nil, query, 'Update the repository cache and try again.', 'Rebuilds your local cache from GitHub, then searches again; gh-update to rebuild anytime.', 'yes', 'FE3390F7-206C-45C4-94BB-5DD14DE23A1B.png')
        end
      end
    end

    puts output
  end
rescue AuthenticationError => e
  main_message, secondary_message = e.message.split("/", 2)
  output = XmlBuilder.build do |xml|
    xml.items do
      xml.item Item.new('gh-error', 'gh-auth', main_message, secondary_message, 'yes')
    end
  end

  puts output
end
